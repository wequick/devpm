# -*- coding:utf-8 -*-

# This file is part of devpm.
#
# Copyright (c) 2023 wequick
# This software is distributed under the MIT license.

import os
import stat
import subprocess

# Git管理
class Git:
  def __init__(self):
    self.bin = 'git'
    self.shell = False
    self.cwd = None

  def init(self):
    try:
      subprocess.check_call(['git', '--version'], self.shell)
      return True
    except:
      return False

  def run(self, args, cwd):
    args.insert(0, self.bin)
    try:
      return subprocess.check_output(args, shell=self.shell, cwd=cwd).decode('utf-8').strip()
    except:
      return None

  def root_path(self, cwd):
    dir = os.path.join(cwd, '.git')
    if os.path.exists(dir):
      return cwd
    dir = self.run(['rev-parse', '--show-toplevel'], cwd=cwd)

  def git_path(self, cwd = None):
    cwd = cwd or self.cwd or os.getcwd()
    path = self.run(['rev-parse', '--git-dir'], cwd=cwd)
    if not path:
      return None
    return os.path.abspath(os.path.join(cwd, path))
  
  def append_hook(self, root_path, git_path, name, hook, apply_submodules):
    t = hook['type'] if 'type' in hook else None
    if not t:
      return
    if t == 'exec':
      return self.append_hook_script(git_path, name, hook['bin'], '.', apply_submodules)
    elif t == 'regexp':
      # write git-hook file
      s = '#!/usr/bin/env python\n# coding=utf-8\n\n# Auto-generated by devpm.\n'
      s += '\nimport os\nimport re\nimport sys\n\n\n'
      s += 'def error():\n'
      for tip in hook['tips']:
        s += '  print("%s")\n' % tip
      s += '  exit(1)\n\n'
      s += "\nif len(sys.argv) > 1:\n"
      s += "  msg = sys.argv[1]\n"
      s += "  if os.path.exists(msg):\n"
      s += "    with open(msg, 'r', encoding='utf-8') as f:\n"
      s += "      msg = f.read()\n"
      s += "  if not re.match('%s', msg):\n" % hook['pattern']
      s += "    error()\n"
      script_dir = os.path.join(root_path, 'dev_modules', 'git-hooks')
      if not os.path.exists(script_dir):
        os.makedirs(script_dir)
      script_file = os.path.join(script_dir, name)
      with open(script_file, 'w', encoding='utf-8') as f:
        f.write(s)
      script_bin = 'dev_modules/git-hooks/%s' % name
      return self.append_hook_script(git_path, name, script_bin, '.', apply_submodules)
    elif t == 'pre-commit':
      self.install_pre_commit(hook, root_path)

  def append_hook_script(self, git_path, name, script_file, script_dir, apply_submodules):
    hook_path = os.path.join(git_path, 'hooks')
    hook_enabled = len(script_file) > 0
    if hook_enabled:
      if not os.path.exists(script_file):
        print('script file not exists: %s' % script_file)
        return
      st = os.stat(script_file)
      os.chmod(script_file, st.st_mode | stat.S_IEXEC)
    
    scaffold_exec = 'SCFEXE=exec;$SCFEXE'
    script = '%s %s/%s $1' % (scaffold_exec, script_dir, script_file)
    if os.path.exists(hook_path):
      print('append_hook check [%s/hooks/%s]' % (git_path, name))
      hook_file = os.path.join(hook_path, name)
      new_file_content = None
      if not os.path.exists(hook_file):
        if hook_enabled:
          new_file_content = '#!/bin/bash\n\n# Auto-generated by devpm.\n' + script + '\n'
      else:
        with open(hook_file, 'r', encoding='utf-8') as f:
          needs_update = False
          file_content = ''
          for line in f.readlines():
            index = line.find(scaffold_exec)
            if index < 0:
              file_content += line
            else:
              hook_added = not '#' in line[:index]
              if hook_added == hook_enabled:
                if not hook_enabled or script == line.strip():
                  break
                needs_update = True
                file_content += script + '\n'
              else:
                needs_update = True
                if hook_enabled:
                  file_content += script + '\n'
                else:
                  file_content += '# ' + line
          if needs_update:
            new_file_content = file_content
      if new_file_content:
        with open(hook_file, 'w', encoding='utf-8') as f:
          f.write(new_file_content)
          print('append_hook [%s/hooks/%s]:\n%s' % (git_path, name, new_file_content))
      st = os.stat(hook_file)
      os.chmod(hook_file, st.st_mode | stat.S_IEXEC)

    if apply_submodules:
      submodules_path = os.path.join(git_path, 'modules')
      if os.path.exists(submodules_path):
        for _, ds, _ in os.walk(submodules_path):
          for d in ds:
            self.append_hook_script(os.path.join(submodules_path, d), name, script_file, '..', True)
  
  def list_git_path(self, git_path, list_submodules = True):
    if not os.path.exists(git_path):
      return
    yield git_path, False
    submodules_path = os.path.join(git_path, 'modules')
    if list_submodules and os.path.exists(submodules_path):
      for rel_f in os.listdir(submodules_path):
        abs_f = os.path.join(submodules_path, rel_f)
        if os.path.isdir(abs_f):
          yield abs_f, True
  
  def list_root_path(self, root_path, list_submodules = True):
    if not os.path.exists(root_path):
      return
    yield root_path, False
    git_path = self.git_path(root_path)
    if git_path:
      submodules_path = os.path.join(git_path, 'modules')
      if list_submodules and os.path.exists(submodules_path):
        for rel_f in os.listdir(submodules_path):
          abs_f = os.path.join(root_path, rel_f)
          if os.path.isdir(abs_f):
            yield abs_f, True

  def install_pre_commit(self, hook, cwd):
    # 配置文件初始化
    import yaml
    name = '.pre-commit-config.yaml'
    target_pre_commit_config = os.path.join(cwd, name)
    new_file_content = None
    data = {}
    cfg_repos = hook['repos']
    if not os.path.exists(target_pre_commit_config):
      data['repos'] = cfg_repos
      new_file_content = yaml.dump(data)
    else:
      file_content = ''
      with open(target_pre_commit_config, 'r', encoding='utf-8') as f:
        file_content = f.read()
        data = yaml.load(file_content, Loader=yaml.FullLoader)
      if not 'repos' in data:
        data['repos'] = cfg_repos
      else:
        for cfg_repo in cfg_repos:
          has_repo = False
          data['repos'] = [x for x in data['repos'] if 'repo' in x]
          for repo in data['repos']:
            if repo['repo'] != cfg_repo['repo']:
              continue
            has_repo = True
            repo['rev'] = cfg_repo['rev']
            if not 'hooks' in repo:
              repo['hooks'] = cfg_repo['hooks']
            else:
              for cfg_hook in cfg_repo['hooks']:
                id = cfg_hook['id']
                found = False
                for hook in repo['hooks']:
                  if id == hook['id']:
                    found = True
                    break
                if not found:
                  repo['hooks'].append(cfg_hook)
          if not has_repo:
            data['repos'].append(cfg_repo)
      new_file_content = yaml.dump(data)
      if file_content == new_file_content:
        new_file_content = None
    if new_file_content:
      print('update %s' % (name))
      with open(target_pre_commit_config, 'w', encoding='utf-8') as f:
        f.write(new_file_content)
    # 遍历所有子模块，执行 pre-commit instal
    for module_path, is_sumbodule in self.list_root_path(cwd):
      try:
        subprocess.check_call(['pre-commit', 'install'], cwd=module_path)
        if is_sumbodule:
          # 子模块需要更新 .pre-commit-config.yaml -> ../.pre-commit-config.yaml
          module_git_path = self.git_path(module_path)
          if module_git_path:
            pre_commit_file = os.path.join(module_git_path, 'hooks', 'pre-commit')
            if os.path.exists(pre_commit_file):
              print('  - fix .pre-commit-config.yaml path for submodule [%s]' % os.path.relpath(module_path, cwd))
              s = ''
              with open(pre_commit_file, 'r', encoding='utf-8') as f:
                s = f.read()
              s = s.replace('.pre-commit-config.yaml', '../.pre-commit-config.yaml')
              with open(pre_commit_file, 'w', encoding='utf-8') as f:
                f.write(s)
      except:
        pass
    return None


if __name__ == '__main__':
  # test
  git = Git()
  git.init()
  # print(os.getcwd())
  # print(git.root_path(os.getcwd()))
  # git_path = git.git_path(os.getcwd())
  # git.append_hook(git_path, 'commit-msg', 'scaffold/git-hooks/commit-msg', '.', True)  # scaffold/git-hooks/commit-msg
  git.run_all_modules('hello', git.root_path(os.getcwd()))
