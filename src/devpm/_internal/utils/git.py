# -*- coding:utf-8 -*-

# This file is part of devpm.
#
# Copyright (c) 2023 wequick
# This software is distributed under the MIT license.

import os
import stat
import subprocess

# Git管理
class Git:
  def __init__(self):
    self.bin = 'git'
    self.shell = False
    self.cwd = None

  def init(self):
    try:
      subprocess.check_call(['git', '--version'], self.shell)
      return True
    except:
      return False

  def run(self, args, cwd):
    args.insert(0, self.bin)
    try:
      return subprocess.check_output(args, shell=self.shell, cwd=cwd).decode('utf-8').strip()
    except:
      return None

  def root_path(self, cwd):
    dir = os.path.join(cwd, '.git')
    if os.path.exists(dir):
      return cwd
    dir = self.run(['rev-parse', '--show-toplevel'], cwd=cwd)

  def git_path(self, cwd = None):
    cwd = cwd or self.cwd or os.getcwd()
    path = self.run(['rev-parse', '--git-dir'], cwd=cwd)
    if not path:
      return None
    return os.path.abspath(os.path.join(cwd, path))

  def append_hook(self, git_path, name, script_file, script_dir, apply_submodules):
    hook_path = os.path.join(git_path, 'hooks')
    hook_enabled = len(script_file) > 0
    scaffold_exec = 'SCFEXE=exec;$SCFEXE'
    script = '%s %s/%s $1' % (scaffold_exec, script_dir, script_file)
    if os.path.exists(hook_path):
      print('append_hook check [%s/hooks/%s]' % (git_path, name))
      hook_file = os.path.join(hook_path, name)
      new_file_content = None
      if not os.path.exists(hook_file):
        if hook_enabled:
          new_file_content = '#!/bin/bash\n\n# Auto-generated by scaffold.\n' + script + '\n'
      else:
        with open(hook_file, 'r') as f:
          needs_update = False
          file_content = ''
          for line in f.readlines():
            index = line.find(scaffold_exec)
            if index < 0:
              file_content += line
            else:
              hook_added = not '#' in line[:index]
              if hook_added == hook_enabled:
                if not hook_enabled or script == line.strip():
                  break
                needs_update = True
                file_content += script + '\n'
              else:
                needs_update = True
                if hook_enabled:
                  file_content += script + '\n'
                else:
                  file_content += '# ' + line
          # if not has_hook and hook_enabled:
          #   needs_update = True
          #   file_content += script + '\n'
          if needs_update:
            new_file_content = file_content
      if new_file_content:
        with open(hook_file, 'w') as f:
          f.write(new_file_content)
          print('append_hook [%s/hooks/%s]:\n%s' % (git_path, name, new_file_content))
      st = os.stat(hook_file)
      os.chmod(hook_file, st.st_mode | stat.S_IEXEC)

    if apply_submodules:
      submodules_path = os.path.join(git_path, 'modules')
      if os.path.exists(submodules_path):
        for _, ds, _ in os.walk(submodules_path):
          for d in ds:
            self.append_hook(os.path.join(submodules_path, d), name, script_file, '..', True)
  
  def list_git_path(self, git_path, list_submodules = True):
    if not os.path.exists(git_path):
      return
    yield git_path, False
    submodules_path = os.path.join(git_path, 'modules')
    if list_submodules and os.path.exists(submodules_path):
      for rel_f in os.listdir(submodules_path):
        abs_f = os.path.join(submodules_path, rel_f)
        if os.path.isdir(abs_f):
          yield abs_f, True
  
  def list_root_path(self, root_path, list_submodules = True):
    if not os.path.exists(root_path):
      return
    yield root_path, False
    git_path = self.git_path(root_path)
    if git_path:
      submodules_path = os.path.join(git_path, 'modules')
      if list_submodules and os.path.exists(submodules_path):
        for rel_f in os.listdir(submodules_path):
          abs_f = os.path.join(root_path, rel_f)
          if os.path.isdir(abs_f):
            yield abs_f, True

  def install_pre_commit(self, _, cwd):
    # 配置文件初始化
    import yaml
    name = '.pre-commit-config.yaml'
    target_pre_commit_config = os.path.join(cwd, name)
    new_file_content = None
    data = {}
    default_repo = {'repo': 'https://github.com/pocc/pre-commit-hooks', 'rev': 'v1.3.5', 'hooks': [{'id': 'cpplint'}, {'id': 'cppcheck'}]}
    if not os.path.exists(target_pre_commit_config):
      data['repos'] = [default_repo]
      new_file_content = yaml.dump(data)
    else:
      file_content = ''
      with open(target_pre_commit_config, 'r') as f:
        file_content = f.read()
        data = yaml.load(file_content, Loader=yaml.FullLoader)
      if not 'repos' in data:
        data['repos'] = [default_repo]
      else:
        has_pocc_repo = False
        data['repos'] = [x for x in data['repos'] if 'repo' in x]
        for repo in data['repos']:
          if repo['repo'] != default_repo['repo']:
            continue
          has_pocc_repo = True
          repo['rev'] = 'v1.3.5'
          if not 'hooks' in repo:
            repo['hooks'] = default_repo['hooks']
          else:
            has_cpplint = False
            has_cppcheck = False
            for hook in repo['hooks']:
              if 'id' in hook:
                if hook['id'] == 'cpplint':
                  has_cpplint = True
                elif hook['id'] == 'cppcheck':
                  has_cppcheck = True
            if not has_cpplint:
              repo['hooks'].append({'id': 'cpplint'})
            if not has_cppcheck:
              repo['hooks'].append({'id': 'cppcheck'})
        if not has_pocc_repo:
          data['repos'].append(default_repo)
      new_file_content = yaml.dump(data)
      if file_content == new_file_content:
        new_file_content = None
    if new_file_content:
      print('update %s' % (name))
      with open(target_pre_commit_config, 'w') as f:
        f.write(new_file_content)
    # 遍历所有子模块，执行 pre-commit instal
    for module_path, is_sumbodule in self.list_root_path(cwd):
      try:
        subprocess.check_call(['pre-commit', 'install'], cwd=module_path)
        if is_sumbodule:
          # 子模块需要更新 .pre-commit-config.yaml -> ../.pre-commit-config.yaml
          module_git_path = self.git_path(module_path)
          if module_git_path:
            pre_commit_file = os.path.join(module_git_path, 'hooks', 'pre-commit')
            if os.path.exists(pre_commit_file):
              print('  - fix .pre-commit-config.yaml path for submodule [%s]' % os.path.relpath(module_path, cwd))
              s = ''
              with open(pre_commit_file, 'r') as f:
                s = f.read()
              s = s.replace('.pre-commit-config.yaml', '../.pre-commit-config.yaml')
              with open(pre_commit_file, 'w') as f:
                f.write(s)
      except:
        pass
    return None


if __name__ == '__main__':
  # test
  git = Git()
  git.init()
  # print(os.getcwd())
  # print(git.root_path(os.getcwd()))
  # git_path = git.git_path(os.getcwd())
  # git.append_hook(git_path, 'commit-msg', 'scaffold/git-hooks/commit-msg', '.', True)  # scaffold/git-hooks/commit-msg
  git.run_all_modules('hello', git.root_path(os.getcwd()))
